---
title: "Toying around with MariaDB : query cache edition"
date: Mon, 30 Jun 2025 13:02:05 GMT
lastUpdated: 2025-06-30T13:02:05.508Z
link: https://medium.com/@arbaudie.it/toying-around-with-mariadb-query-cache-edition-c9c7fa742127?source=rss-c779d007e7fe------2
---

<h3>Toying around with MariaDB : query cache edition</h3><p><a href="https://mariadb.org/documentation/">MariaDB</a>’s <a href="https://mariadb.com/kb/en/query-cache">query cache</a> , as explained <a href="https://mariadb.com/kb/en/query-cache/#how-the-query-cache-works">here</a> is a legacy memory-based mechanism which stores the results of SELECT queries to avoid recalculating them when identical queries are executed again. When a SELECT query is run, MariaDB first checks if the result already exists in the cache and returns it directly if found, which significantly improves performance for repetitive queries. The cache is automatically maintained ensuring data consistency in returned results.</p><p>It is easy to setup with two simple parameters and <a href="https://mariadb.com/kb/en/server-system-variables/#query_cache_strip_comments">an optional third</a> to prevents some typos, untrimmed spaces and comments to get in the way, as follows :</p><pre>query_cache_type = ON<br />query_cache_size = 28M<br /><br />query_cache_strip_comments = 1 #optional</pre><p>This feature has been introduced in MySQL 4.0 in 2002 and its main issue is being monolatched thus explaining very poor scalability and locking issues for high write concurrency as mentionned <a href="https://shatteredsilicon.net/mysql-waiting-for-query-cache-lock/">here</a> by the good folks of <a href="https://www.linkedin.com/company/shatteredsilicon/posts/">shattered silicon</a>. This is why it is recomended to disable it by defaut. Beware tho in MariaDB 10.6+ you have to set <strong>both</strong> following parameters to disable it :</p><pre>query_cache_type = 0 <br />query_cache_size = 0</pre><p>It seems not many people know about a third mode of the query cache which is setup this way :</p><pre>query_cache_type = ON_DEMAND</pre><p>This setup disables query caching by default but allows you to selectively cache specific queries by adding the <a href="https://mariadb.com/kb/en/query-cache/#sql_no_cache-and-sql_cache">SQL_CACHE hint</a> to individual SELECT statements as follows</p><pre>SELECT SQL_CACHE my_columns FROM mytables WHERE my_other_column = this_value;</pre><p>This gives you fine-grained control over which queries get cached rather than caching everything by default. It can be massively usefull when you have a mixed load but can identify a pattern of long TTL datas that are queried quite often. This is typically the case in a CMS or in a product catalog management system where the description pages don’t change much over time.</p><p>Whichever way, using the query cache means monitoring what it does. This can be performed through the observation of the <a href="https://mariadb.com/kb/en/server-status-variables/#qcache_free_blocks">Qcache status variables</a>. The most watched metrics is the hit ratio :</p><pre>Qcache_hits / (Qcache_hits + Qcache_inserts + Qcache_not_cached)</pre><p>and you want it to be over 40%, the more the better. Next comes the insert-to-read ratio</p><pre>Qcache_hits / Qcache_inserts</pre><p>aiming to monitor the usefulness . Next, is the cache big enough ? Qcache_low_mem_prunes vs Qcache_inserts is telling you just that.</p><p>Installing the <a href="https://mariadb.com/kb/en/query-cache-information-plugin/">Query Cache Information plugin</a> can also provide with some interesting insights as you can see (and some more) depending on the MariaDB server version :</p><pre>SELECT * FROM information_schema.QUERY_CACHE_INFO;<br />+------------------+-----------------+---------------------+--------------------+-------------------------+<br />| STATEMENT_SCHEMA | STATEMENT_TEXT  | RESULT_BLOCKS_COUNT | RESULT_BLOCKS_SIZE | RESULT_BLOCKS_SIZE_USED |<br />+------------------+-----------------+---------------------+--------------------+-------------------------+<br />...<br />| test             | SELECT * FROM a |                   1 |                512 |                     143 |<br />| test             | select * FROM a |                   1 |                512 |                     143 |<br />...<br />+------------------+-----------------+---------------------+--------------------+-------------------------</pre><p>Beware tho, if you run ON_DEMAND mode, the monitoring is much more complicated to monitor since the hit ratio is almost impossible to compute.</p><p>Of course, in the case of a distributed architecture, like a <a href="https://mariadb.com/kb/en/getting-started-with-mariadb-galera-cluster/">Galera cluster</a> or an <a href="https://mariadb.com/kb/en/standard-replication/">asynchronous master-replica replication</a> topology , each server will have to manage its own Query cache, reducing the overall efficiency. If you are using a proxy such as <a href="https://mariadb.com/kb/en/mariadb-maxscale-2106-maxscale-2106-about-mariadb-maxscale/">Maxscale</a> for managing the readwritesplitting, you can add to the service a <a href="https://mariadb.com/kb/en/mariadb-maxscale-2106-cache/">cache filter</a> that will provide caching for the whole topology. Now the question is : when is which approach worth it ?</p><p>Obviously, if you dont use Maxscale, then the Query cache stays a very interesting piece of software.</p><p>Funnily enough, a few days after finishing redacting this story i attended a roadshow during which one of the presenters stated that they cannot disable the query cache without breaking their app. A clear sign that despite being severly outdated and desperatly needing some love, it is still an interesting piece of software.</p><p>And there is more brewing on the topic !!!</p><img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c9c7fa742127" width="1" />
