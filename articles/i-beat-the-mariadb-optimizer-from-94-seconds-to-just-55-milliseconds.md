---
title: "I beat the MariaDB optimizer: from  94 seconds to just 55 milliseconds"
date: Tue, 15 Jul 2025 06:10:48 GMT
lastUpdated: 2025-07-15T06:10:48.738Z
link: https://medium.com/@arbaudie.it/i-beat-the-mariadb-optimizer-from-94-seconds-to-just-55-milliseconds-ea4fa9378e44?source=rss-c779d007e7fe------2
---

<h3>I beat the MariaDB optimizer: from 94 seconds to just 55 milliseconds</h3><p>Some client of mine recently migrated from MySQL 8 to <a href="https://mariadb.com/docs/release-notes/mariadb-community-server-release-notes/mariadb-11-4-series">MariaDB 11.4CS</a>. YAY to them !!!!</p><p>As a side effect, this particular query saw a massive performance drop down to 1min 34sec from 148ms. NAY to this !!!!</p><pre>SELECT<br />    sd.ID,<br />    sd.NUMERO_DOSSIER,<br />    sd.LAST_SYNC_DATE,<br />    sd.NS_REFERENCE,<br />    sd.METIER,<br />    sd.STATUS,<br />    sd.IS_SCHEDULED<br />FROM<br />    schema1.sync_dossier sd<br />LEFT JOIN schema2.dossier d<br />ON<br />    d.NUMERO_DOSSIER = sd.NUMERO_DOSSIER<br />WHERE<br />    d.NUMERO_DOSSIER IS NULL AND sd.METIER = &quot;sps&quot;<br />LIMIT 10;</pre><p>It is decently easy to understand why : <a href="https://www.mariadbtutorial.com/mariadb-basics/mariadb-left-join/">LEFT JOINs</a> with searching only for NULL values usually means you have to read the whole table (or an index in the best case scenario) in order to verify you can’t find a match. And that exactly what the <a href="https://mariadb.com/docs/server/reference/sql-statements/administrative-sql-statements/analyze-and-explain-statements/explain">explain plan</a> tells us.</p><pre>{<br />  &quot;query_block&quot;: {<br />    &quot;select_id&quot;: 1,<br />    &quot;cost&quot;: 515583.5373,<br />    &quot;nested_loop&quot;: [<br />      {<br />        &quot;table&quot;: {<br />          &quot;table_name&quot;: &quot;sd&quot;,<br />          &quot;access_type&quot;: &quot;ref&quot;,<br />          &quot;possible_keys&quot;: [&quot;sync_dossier_METIER_index&quot;],<br />          &quot;key&quot;: &quot;sync_dossier_METIER_index&quot;,<br />          &quot;key_length&quot;: &quot;34&quot;,<br />          &quot;used_key_parts&quot;: [&quot;METIER&quot;],<br />          &quot;ref&quot;: [&quot;const&quot;],<br />          &quot;loops&quot;: 1,<br />          &quot;rows&quot;: 85114,<br />          &quot;cost&quot;: 85.64544048,<br />          &quot;filtered&quot;: 100,<br />          &quot;index_condition&quot;: &quot;classement_email.sd.METIER = 'sps'&quot;<br />        }<br />      },<br />      {<br />        &quot;block-nl-join&quot;: {<br />          &quot;table&quot;: {<br />            &quot;table_name&quot;: &quot;d&quot;,<br />            &quot;access_type&quot;: &quot;index&quot;,<br />            &quot;key&quot;: &quot;DATE_DERNIERE_MODIF&quot;,<br />            &quot;key_length&quot;: &quot;6&quot;,<br />            &quot;used_key_parts&quot;: [&quot;DATE_DERNIERE_MODIFICATION&quot;],<br />            &quot;loops&quot;: 85114,<br />            &quot;rows&quot;: 41219,<br />            &quot;cost&quot;: 515497.8918,<br />            &quot;filtered&quot;: 100,<br />            &quot;using_index&quot;: true,<br />            &quot;not_exists&quot;: true<br />          },<br />          &quot;buffer_type&quot;: &quot;flat&quot;,<br />          &quot;buffer_size&quot;: &quot;2048Kb&quot;,<br />          &quot;join_type&quot;: &quot;BNL&quot;,<br />          &quot;attached_condition&quot;: &quot;trigcond(csps.d.NUMERO_DOSSIER is null) and trigcond(convert(csps.d.NUMERO_DOSSIER using utf8mb3) = classement_email.sd.NUMERO_DOSSIER)&quot;<br />        }<br />      }<br />    ]<br />  }</pre><p>We can notice that the first data lookup is performed by parsing the <em>sync_dossier_METIER_index</em> index once. It expects to find 85114 rows that matches the condition</p><pre>&quot;table&quot;: {<br />          &quot;table_name&quot;: &quot;sd&quot;,<br /><br />          &quot;key&quot;: &quot;sync_dossier_METIER_index&quot;,<br /><br />          &quot;loops&quot;: 1,<br />          &quot;rows&quot;: 85114,<br />          &quot;cost&quot;: 85.64544048,</pre><p>Then for each of those match, it will have to parse the whole 41219 entries of the <em>DATE_DERNIERE_MODIF</em> index in order to verify the no-match clause.</p><pre>&quot;table&quot;: {<br />            &quot;table_name&quot;: &quot;d&quot;,<br /><br />            &quot;key&quot;: &quot;DATE_DERNIERE_MODIF&quot;,<br /><br />            &quot;loops&quot;: 85114,<br />            &quot;rows&quot;: 41219,<br />            &quot;cost&quot;: 515497.8918,</pre><p>That’s 3 508 313 966 ( like 85114 * 41219 ) rows to parse !!! No wonder this takes a looooooooooong time.</p><p>Okay, now we know what’s wrong with the query, let’s focus on making it faster. The main idea is to change the way we retrieve datas and writing the search in natural language helps finding the right paradigm. if you remember my <a href="https://medium.com/@arbaudie.it/how-to-distinguish-facts-attributes-and-relations-from-bullshit-d9791835090b">stories about data modeling</a>, i have extensively discussed about that. So what do we search for ?</p><p>We want all values that exists in <em>schema1.sync_dossier</em> but <a href="https://mariadb.com/docs/server/reference/sql-structure/operators/comparison-operators/not-in">not in</a> <em>schema2.dossier</em>. Which can be also be put as : we want the values of <em>schema1.sync_dossier</em> <a href="https://mariadb.com/docs/server/reference/sql-statements/data-manipulation/selecting-data/joins-subqueries/except"><strong>MINUS</strong></a><strong> </strong>the values <em>schema2.dossier</em>. That’s about it ! Instead of using costly left outer joins, let’s call on the <a href="https://mariadb.com/resources/blog/mariadb-sql-set-operators/">set operators</a>. It should be way better since all we need are two sets of values and substract the second from the first. As this would imply a derived table or a subquery, let’s make good use of <a href="https://mariadb.com/docs/server/reference/sql-statements/data-manipulation/selecting-data/common-table-expressions">CTEs</a> since they are fully standardized since SQL:99 and integrated in MariaDB 10.2 (10.3 for the recursive CTEs standardized in SQL:2003).</p><p>The query now runs in 348ms and looks like this :</p><pre>WITH dossiers as (<br />select NUMERO_DOSSIER from schema2.sync_dossier<br />WHERE sd.METIER = &quot;sps&quot;<br />EXCEPT<br />select NUMERO_DOSSIER from schema1.dossier d <br />)<br />SELECT<br />    sd.ID,<br />    sd.NUMERO_DOSSIER,<br />    sd.LAST_SYNC_DATE,<br />    sd.NS_REFERENCE,<br />    sd.METIER,<br />    sd.STATUS,<br />    sd.IS_SCHEDULED<br />FROM dossiers d<br />JOIN schema2.sync_dossier sd ON d.NUMERO_DOSSIER = sd.NUMERO_DOSSIER<br />LIMIT 10;</pre><p>With a little bit more of brain time, i realized that the limit should be run into the CTE as it does make no sense to get 85k rows and filter them at the very end. So final form of query looks like this :</p><pre>WITH dossiers as (<br />( select NUMERO_DOSSIER from schema2.sync_dossier<br />WHERE sd.METIER = &quot;sps&quot; )<br />EXCEPT<br />( select NUMERO_DOSSIER from schema1.dossier d )<br />LIMIT 10 <br />)<br />SELECT<br />    sd.ID,<br />    sd.NUMERO_DOSSIER,<br />    sd.LAST_SYNC_DATE,<br />    sd.NS_REFERENCE,<br />    sd.METIER,<br />    sd.STATUS,<br />    sd.IS_SCHEDULED<br />FROM dossiers d<br />JOIN schema2.sync_dossier sd ON d.NUMERO_DOSSIER = sd.NUMERO_DOSSIER;</pre><p>It now executes in 55ms. YAY to this !!!! <br />On the other hand, the execution plan is now somewhat less human friendly.</p><pre>{<br />   &quot;query_block&quot;:{<br />      &quot;select_id&quot;:1,<br />      &quot;cost&quot;:158.5190533,<br />      &quot;nested_loop&quot;:[<br />         {<br />            &quot;table&quot;:{<br />               &quot;table_name&quot;:&quot;&lt;derived2&gt;&quot;,<br />               &quot;access_type&quot;:&quot;ALL&quot;,<br />               &quot;possible_keys&quot;:[<br />                  &quot;distinct_key&quot;<br />               ],<br />               &quot;loops&quot;:1,<br />               &quot;rows&quot;:75718,<br />               &quot;cost&quot;:18.28721726,<br />               &quot;filtered&quot;:100,<br />               &quot;attached_condition&quot;:&quot;dossier.NUMERO_DOSSIER is not null&quot;,<br />               &quot;materialized&quot;:{<br />                  &quot;query_block&quot;:{<br />                     &quot;union_result&quot;:{<br />                        &quot;table_name&quot;:&quot;&lt;except2,3&gt;&quot;,<br />                        &quot;access_type&quot;:&quot;ALL&quot;,<br />                        &quot;query_specifications&quot;:[<br />                           {<br />                              &quot;query_block&quot;:{<br />                                 &quot;select_id&quot;:2,<br />                                 &quot;cost&quot;:29.6640134,<br />                                 &quot;nested_loop&quot;:[<br />                                    {<br />                                       &quot;table&quot;:{<br />                                          &quot;table_name&quot;:&quot;sync_dossier&quot;,<br />                                          &quot;access_type&quot;:&quot;ALL&quot;,<br />                                          &quot;possible_keys&quot;:[<br />                                             &quot;sync_dossier_METIER_index&quot;<br />                                          ],<br />                                          &quot;loops&quot;:1,<br />                                          &quot;rows&quot;:176719,<br />                                          &quot;cost&quot;:29.6640134,<br />                                          &quot;filtered&quot;:42.8465538,<br />                                          &quot;attached_condition&quot;:&quot;classement_email.sync_dossier.METIER = 'sps'&quot;<br />                                       }<br />                                    }<br />                                 ]<br />                              }<br />                           },<br />                           {<br />                              &quot;query_block&quot;:{<br />                                 &quot;select_id&quot;:3,<br />                                 &quot;operation&quot;:&quot;EXCEPT&quot;,<br />                                 &quot;cost&quot;:6.101592365,<br />                                 &quot;nested_loop&quot;:[<br />                                    {<br />                                       &quot;table&quot;:{<br />                                          &quot;table_name&quot;:&quot;dossier&quot;,<br />                                          &quot;access_type&quot;:&quot;index&quot;,<br />                                          &quot;key&quot;:&quot;DATE_DERNIERE_MODIF&quot;,<br />                                          &quot;key_length&quot;:&quot;6&quot;,<br />                                          &quot;used_key_parts&quot;:[<br />                                             &quot;DATE_DERNIERE_MODIFICATION&quot;<br />                                          ],<br />                                          &quot;loops&quot;:1,<br />                                          &quot;rows&quot;:40817,<br />                                          &quot;cost&quot;:6.101592365,<br />                                          &quot;filtered&quot;:100,<br />                                          &quot;using_index&quot;:true<br />                                       }<br />                                    }<br />                                 ]<br />                              }<br />                           }<br />                        ]<br />                     }<br />                  }<br />               }<br />            }<br />         },<br />         {<br />            &quot;table&quot;:{<br />               &quot;table_name&quot;:&quot;sd&quot;,<br />               &quot;access_type&quot;:&quot;eq_ref&quot;,<br />               &quot;possible_keys&quot;:[<br />                  &quot;sync_dossier_NUMERO_DOSSIER_index&quot;<br />               ],<br />               &quot;key&quot;:&quot;sync_dossier_NUMERO_DOSSIER_index&quot;,<br />               &quot;key_length&quot;:&quot;768&quot;,<br />               &quot;used_key_parts&quot;:[<br />                  &quot;NUMERO_DOSSIER&quot;<br />               ],<br />               &quot;ref&quot;:[<br />                  &quot;dossier.NUMERO_DOSSIER&quot;<br />               ],<br />               &quot;loops&quot;:75718,<br />               &quot;rows&quot;:1,<br />               &quot;cost&quot;:140.2318361,<br />               &quot;filtered&quot;:100<br />            }<br />         }<br />      ]<br />   }<br />}</pre><p>But it still shows (as seen below) that, according to what we expected, all tables/indexes are read exactly once, which is a massive win from the inital execution plan.</p><pre>&quot;table&quot;:{<br />    &quot;table_name&quot;:&quot;sync_dossier&quot;,<br />    &quot;access_type&quot;:&quot;ALL&quot;,<br /><br />    &quot;loops&quot;:1,<br />    &quot;rows&quot;:176719,<br /><br />&quot;table&quot;:{<br />    &quot;table_name&quot;:&quot;dossier&quot;,<br />    &quot;access_type&quot;:&quot;index&quot;,<br />    <br />    &quot;loops&quot;:1<br />    &quot;rows&quot;:40817,</pre><p>Given this query runs in between 1500 and 2000 times during office hours, this will make a huge difference.</p><p>But we can still do better. In the latest execution plan, we can notice we switched to a FULL TABLE SCAN despite having our where clause indexed. I would not be surprised we could even be a little faster by adding a coumpound index on <em>schema2.sync_dossier(METIER, NUMERO_DOSSIER)</em> or the other way around. This way, we would parse a smaller <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+-tree</a> and still filter out the value we need.</p><p>Last but not least, the client noticed that to parse the second table <em>schema1.dossier</em> we are using an index named <em>DATE_DERNIERE_MODIF</em> based on the column <em>DATE_DERNIERE_MODIFICATION</em> which is not in use in the statement. At first it seems indeed strange, but i think it’s a clever move from the MariaDB devs. Here’s my take on this :</p><p>In order to substract it from the first set of <em>NUMERO_DOSSIER</em> values from <em>schema2.sync_dossier</em>, MariaDB needs to compute the set of <em>NUMERO_DOSSIER</em> values from <em>schema1.dossier</em>. Incidently it is the PK of said table. It could simply parse the main <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+-tree</a> and aggregate PKs from there but this would mean reading the whole table. Now feels like a good time to tell or remember everyone that InnoDB silently adds the PK to each secondary index. It reduces the number of reads by reading the index with the best cardinality for the same end result.</p><p>To wrap it up, if most of the time optimizing a query means setting the index rights and having the statistics up to date, sometimes it means tapping into some more brainpower and rewrite it in a more convenient way to help the optimizer compute the right path. And that’s usually where you can see the craziest performance gains, such as this one.</p><p>Now tell me, who would not like to benefit from such feats and knowledge ? <a href="https://arbaudie.it">Reach out to me</a> and le’ts see what you need and how i can help you solve those pain point of yours !!</p><img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ea4fa9378e44" width="1" />
