---
title: "Embrace simplicity"
date: Thu, 09 Jan 2025 16:48:51 GMT
lastUpdated: 2025-01-09T16:48:51.116Z
link: https://medium.com/@arbaudie.it/embrace-simplicity-8f3fa62d7167?source=rss-c779d007e7fe------2
---

<p>The <a href="https://medium.com/itnext/the-list-of-architectural-metapatterns-ed64d8ba125d">evolution of software architecture</a> has seen a significant shift from traditional spaghetti monoliths to more distributed and flexible approaches. Initial tightly-coupled monolithic systems, often characterized by complex interdependencies were rather difficult to maintain and a nightmare to scale. This lack of flexibility and fault isolation prompted the development of <strong>S</strong>ervice-<strong>O</strong>riented <strong>A</strong>rchitecture in the early 2000s. SOA introduced the concept of loosely coupled services, enhancing reusability and interoperability. However, the rather centralized nature of SOA became a bottleneck as some systems grew more complex.</p><p>In response to these limitations, microservices architecture emerged in the early 2010s. Alongside microservices, <strong>E</strong>vent-<strong>D</strong>riven <strong>A</strong>rchitecture (EDA) gained prominence, focusing on asynchronous communication between services, promoting loose coupling and real-time responsiveness, further improving system scalability and resilience. Basically the next-gen SOA.</p><p>As these architectural paradigms evolved, they coincided with the rise of a DevOps culture. Emphasizing on collaboration between development and operations teams, it encourages practices such as <strong>C</strong>ontinuous <strong>I</strong>ntegration/<strong>C</strong>ontinuous <strong>D</strong>elivery with the support of <strong>I</strong>nfrastructure <strong>a</strong>s <strong>C</strong>ode, containerization technologies or even orchestration tools such as Kubernetes. Those have all transformed how applications are deployed and managed in cloud environments.</p><p>However, the rapid adoption of these advanced architectural patterns and technologies has also led to numerous instances of overengineering in many organizations. Overengineering often result in increased development time, higher maintenance costs, and reduced overall system efficiency. For example, breaking down a simple application into numerous microservices when a well designed monolithic approach would suffice, or implementing a complex event-driven system for straightforward synchronous processes, can introduce unwarranted complexity with associated inflated costs for little-to-no gain. Similarly, adopting containerization and orchestration tools for small-scale applications that don’t require such scalability usually lead to increased operational overhead without commensurate benefits.</p><p>Recent publications from organizations <a href="https://thenewstack.io/why-companies-are-ditching-the-cloud-the-rise-of-cloud-repatriation/">leaving hyperscalers</a> and <a href="https://benhouston3d.com/blog/why-i-left-kubernetes-for-google-cloud-run">Kubernetes</a> highlight those concerns. It’s crucial for architects and developers to carefully consider the actual needs of their projects and choose appropriate technologies and patterns that align with their specific requirements, rather than blindly following trends or adopting complex solutions unnecessarily. We are not supposed to be a hype driven flock. Yet we are.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/511/1*YKrQxCHGMMdaOHq6gE4OjQ.png" /></figure><p>So i guess it’s time to go back to the basics and summon again the good ol’ <a href="https://www.geeksforgeeks.org/kiss-principle-in-software-development/">KISS principle</a> from our glorious but forgotten past. The KISS principle, which stands for “Keep It Simple, Stupid,” is a fundamental design philosophy that advocates for simplicity in systems and solutions. Originating in the 1960s, this principle emphasizes the importance of avoiding unnecessary complexity in favor of straightforward, efficient approaches. In software development, KISS encourages developers to write clean, maintainable code that focuses on core functionality without overengineering. By adhering to KISS, teams can create more understandable, scalable, and robust systems that are easier to debug and maintain over time. This principle serves as a valuable counterbalance to the increasing complexity of modern software architectures, reminding us that sometimes, the simplest solution is often the most effective.</p><p>At the end of the day, we should always get back to asking the question: what issue am I trying to solve/avoid? What are the constraints? Overengineering often stems from a failure to critically examine these fundamental questions, leading developers and architects to create complex solutions for problems that may not even exist or require such elaborate approaches. By maintaining a laser-focused perspective on the actual business or technical challenge at hand, teams can avoid the trap of unnecessary complexity and instead design systems that are lean, efficient, and truly aligned with their core objectives.</p><img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8f3fa62d7167" width="1" />
