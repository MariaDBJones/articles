---
title: "Cybersec : MariaDB, round2"
date: Sun, 08 Jun 2025 17:08:44 GMT
lastUpdated: 2025-06-08T17:08:44.830Z
link: https://medium.com/@arbaudie.it/cybersec-mariadb-round2-813a2792950b?source=rss-c779d007e7fe------2
---

<h3>Cybersec : MariaDB, round2</h3><p>While being an Open source database management system developped and maintained by a team of immensely skilled developpers, MariaDB (and MySQL) is not immune to mismanagement and/or administrator-induced security risks.</p><p>A not well known feature of MariaDB is <a href="https://mariadb.com/kb/en/server-system-variables/#init_file">init_file</a>, a nice little parameter that allows to have a set of SQL statement executed once at each server startup. While potent and very usefull, this is also a potential security breache, as anyone who can edit this file can add a sql statement creating an admin user for example or expand someone’s privileges beyond any need.</p><p>Let’s examine how we can mitigate this risk while making good use of said feature.</p><p>My first thought would be to prevent easy access to the files. Let’s store both the configuration file and the init file on an encrypted filesystem (also okay if it is an encrypted hardware).</p><pre>sudo cryptsetup luksFormat /dev/sdX  # Replace with your device<br />sudo cryptsetup open /dev/sdX mysql-secure<br />sudo mkfs.ext4 /dev/mapper/mysql-secure<br />mount /dev/mapper/mysql-secure /secure/custom/path</pre><p>Let’s say both files are now <em>/secure/custom/path/init_file.sql</em> and <em>/secure/custom/path/my.cnf</em> . If we use <a href="https://mariadb.com/kb/en/mariadbd-options/#-defaults-extra-file">— defaults-extra-file</a> then this file would be read AFTER the standard config files and pathes. Okayish since MariaDB only keeps the last read value in case of duplicates but it does not really protect as much as we want from configuration tampering. Let’s head back to the <a href="https://mariadb.com/kb/en/configuring-mariadb-with-option-files/">documentation about configuration files</a>. What about <a href="https://mariadb.com/kb/en/mariadbd-options/#-defaults-file">— defaults-file</a> ? As per the doc it only read the specified option file. Just what we look for !<br />So here’s our first step. Let’s change the systemd service definition as follows :</p><pre>[Service]<br />ExecStart=/usr/bin/mariadbd --defaults-file=/secure/custom/path/mariadb.cnf $_WSREP_START_POSITION $_WSREP_NEW_CLUSTER</pre><p>That’s a nice beginning but now we ned to protect the file from tamperingshed. Sarting with the basics, let’s set ownership and permission right as follows :</p><pre>chown +R mariadb: /secure/custom/path/<br />chmod +R 640 /secure/custom/path/</pre><p>Another good point but still not enough as this does not totally prevent access and therefore tampering. Let’s make the files immutable and check the immutability at service startup. Since removing imutability requires root or sudo privileges, an attacker having the ability to remove immutability already has full control of the machine. We would’ve already lost the game so let’s enforce that point as follows :</p><pre>sudo chattr +i /secure/custom/path/mariadb.cnf<br />sudo chattr +i /secure/custom/path/init.sql</pre><p>associated with</p><pre>[Service]<br /># Check if the immutable flag is set on the configuration &amp; init files<br />ExecStartPre=/bin/bash -c 'if ! lsattr /secure/custom/path/mariadb.cnf | grep -q &quot;^....i&quot; ; then echo &quot;Configuration file is not immutable!&quot;; exit 1; fi'<br />ExecStartPre=/bin/bash -c 'if ! lsattr /secure/custom/path/init.sql | grep -q &quot;^....i&quot; ; then echo &quot;init file is not immutable!&quot;; exit 1; fi'</pre><p>Now let’s imagine i am paranoïac (basic skill of any regular security officer btw) and i want to hide the files and mount point from the good people having access the machine. Trust doesnt preclude control, don’t you know ?<br />Instead of mounting the encrypted fs straight, we can actually hide it into a private namespace as follows :</p><pre># /etc/systemd/system/mysqld.service.d/secure-mount.conf<br />[Service]<br />PrivateMounts=yes<br />ExecStartPre=/usr/bin/mount /dev/mapper/mysql-secure /secure/custom/path<br />ExecStopPost=/usr/bin/umount /secure/custom/path</pre><p>Now the only way to access those files is through the service namespace. A pain in the butt, but at least nobody will do it unless they have a very good reason to do so :</p><pre># Get the PID of the mysqld process<br />MYSQL_PID=$(systemctl show --property MainPID --value mysqld)<br /><br /># Enter the mount namespace<br />sudo nsenter -m -t $MYSQL_PID<br /><br /># Now, edit the files within the service's namespace<br />vi /secure/custom/path/my.cnf<br />vi /secure/custom/path/init.sql<br />exit</pre><p>While encrypting the filesystem and hiding its content into a private namespace is good, it is still a passive protection measure. Having a watcher and enforcer on top is a must-have. So let’s create a SELinux policy for that :</p><pre># Create a custom SELinux type for your MariaDB config<br />sudo semanage fcontext -a -t sec_custom_path_t &quot;/secure/custom/path(/.*)?&quot;<br /><br /># Apply the context<br />sudo restorecon -Rv /secure/custom/path<br /><br /># Allow MySQL (mysqld_t) to read/write the directory and files<br />allow mysqld_t sec_custom_path_t:dir { read open search getattr };<br />allow mysqld_t sec_custom_path_t:file { read open getattr write create append };<br /><br /># Allow sudoers (unconfined_t) to access the directory and files<br />allow unconfined_t sec_custom_path_t:dir { read open search getattr write add_name remove_name };<br />allow unconfined_t sec_custom_path_t:file { read open getattr write create append unlink };<br /><br />checkmodule -M -m -o sec_custom_path.mod sec_custom_path.te<br />semodule_package -o sec_custom_path.pp -m sec_custom_path.mod<br />sudo semodule -i sec_custom_path.pp</pre><p>Now, only the service and the sudoers have access to the immutable files, provided they know how to find the related private namespace. Seems like a decent security scheme overall.</p><p>Not perfect by any means, but it should do the trick unless someone gains root or sudo access on your machine. But this usuallly means “gg wp” end of the game.</p><img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=813a2792950b" width="1" />
