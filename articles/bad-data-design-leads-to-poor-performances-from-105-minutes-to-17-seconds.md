---
title: "Bad data design leads to poor performances: from 105 minutes to 17 seconds"
date: Wed, 23 Jul 2025 18:34:38 GMT
lastUpdated: 2025-07-23T18:34:38.850Z
link: https://medium.com/@arbaudie.it/bad-data-design-leads-to-poor-performances-from-105-minutes-to-17-seconds-086a6a42beda?source=rss-c779d007e7fe------2
---

<p>I requested permission to share anonymized queries and execution plans from this case, but the client declined. So, I’ll be providing only high-level explanations and general figures in this story.</p><p>About two years ago, I had the privilege of working with a company in Northern Europe that was struggling to aggregate data from several recently acquired subsidiaries, all operating in the same industry. The core purpose of the system in question was to present a unified webui, allowing customers to track their orders and receive alerts when they were ready for pickup.<br />The technical challenge stemmed from their data structure. They had a legacy table from their original system and a new table populated with <a href="https://medium.com/ssense-tech/event-sourcing-a-practical-guide-to-actually-getting-it-done-27d23d81de04">event-sourced</a> data (yes, I know…) from the newly integrated subsidiaries. Both tables shared a similar structure and core columns.<br />However, because order states were computed and refreshed from a message queue, things got tricky. Also customers could place an order at one subsidiary but choose to pick it up at another. This meant the system had to reconcile state and data changes across both tables to maintain consistency and accuracy.</p><p>Given the sheer volume of data (yeah, well… event sourcing, right?) in both tables, the query — even with proper indexing — took around 1 hour and 45 minutes to execute. As a result, customers could only be alerted about order availability roughly every two hours. The client understandably wanted to tighten the update window, ideally around 15 minutes. To achieve this, they explored external tools and even considered rewriting some parts of the data pipeline. But both solutions were costly. After summarizing their options and kinda hitting a wall, they reached out to <a href="https://mariadb.com">MariaDB Corporation</a> — which led to me stepping in to provide a limited-time <a href="https://www.indeed.com/career-advice/finding-a-job/what-does-technical-account-manager-do">TAM (Technical Account Manager)</a> service.</p><p>We discussed the issue in depth — the background, how things had evolved to this point, and the solution they were envisioning going forward. Eventually, I got to the point of reviewing the actual query and the table structures themselves. And that’s when I stumbled upon a (very) low-hanging fruit: one of the join conditions between the two large tables involved date columns being wrapped in functions — on both sides :</p><pre>CAST(date_column1 AS CHAR) = STR_TO_DATE(date_column2,'%x%c%d')</pre><p>As you probably (and should) know, wrapping columns in functions during joins or filters prevents indexes from being used. In this case, the functions were purely for data type manipulation — casting a DATE and an INTEGER into CHAR just to make them comparable. A quick inspection of the data types involved confirmed the OG issue:</p><pre>TABLE1<br />(<br />...<br />date_column1 INT COMMENT 'YYYYMMDD',<br />...);<br /><br />TABLE2<br />(<br />...<br />date_column2 DATE,<br />...);</pre><p>The client was already pleased that we’d identified a potential performance gain within just a few hours on day one. Now, they were eager to see how much it could actually speed things up. So, how do we fix this — and more importantly, can we do it with minimal disruption ?</p><p>Long story short: yes, we can, so let’s see how.</p><p>Since modifying the loading software was off the table, that also meant we couldn’t touch the existing columns. Thankfully, MariaDB provides a very handy feature for situations like this: <a href="https://mariadb.com/docs/server/reference/sql-statements/data-definition/create/generated-columns">generated columns</a>. A generated column is a virtual or stored column whose value is automatically calculated based on an expression involving other columns in the same table. The expression can use <a href="https://mariadb.com/docs/server/reference/sql-functions">built-in functions</a> or <a href="https://mariadb.com/docs/server/server-usage/user-defined-functions">UDFs (user-defined functions)</a> (<a href="https://medium.com/@arbaudie.it/mariadb-extensibility-dce50baece54">remember that time when i displayed how powerful UDFs can be</a>).</p><p>So the real question became:<br /> Do we create a generated column in one of the tables? Or in both?</p><p>Since we’re aiming for performance, and INTEGER is the fastest data type, we’ll lean into that. Let’s generate a clean, indexed integer value to join on — and keep everything else as it is.</p><pre>ALTER TABLE TABLE2 ADD date_column2_as_int INT AS CAST(DATE_FORMAT(date_column2, '%Y%m%d') AS UNSIGNED) VIRTUAL COMMENT 'YYYYMMDD - for index+join purposes';</pre><p>Now that we have our integer column available on both sides, we can update the join condition in the query to use them directly, as follows:</p><pre>date_column1 = date_column2_as_int</pre><p>Also, to maximize the performance benefits of the new generated column, let’s create an index that mimic the existing one, but replace the plain date column with the generated column:</p><pre>CREATE INDEX idx_match ON TABLE2( ..., date_column2_as_int);</pre><p>After setting up a test environment with the latest production backup, the results were stunning: according to the explain plan, the new indexes were used, and the query now runs in 17 seconds.</p><p><strong>17 SECONDS — HOLY *****!!!</strong></p><p>I knew it would be faster by a solid margin, but wow… just wow.</p><p>To wrap it up, this perfectly illustrates the two key lessons I always share with my performance tuning trainees. First, databases are like buildings — none is stronger/faster than its foundations. Second, data design is the foundation of any database, so invest time and brainpower into it.<strong><br /></strong>And remember: data design is mostly database engine–independent.</p><p>In today’s case, we relied on MariaDB-specific features like generated columns to <em>emulate</em> good data design, because rebuilding from scratch wasn’t an option. But in an ideal world, both tables would have had aligned design, so data types in our case, from the start — and the performance would have been there from the get-go.</p><p>Now tell me, who would not like to benefit from such feats and knowledge ? <a href="https://arbaudie.it/">Reach out to me</a> and le’ts see what you need and how i can help you solve those pain points of yours !!</p><img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=086a6a42beda" width="1" />
